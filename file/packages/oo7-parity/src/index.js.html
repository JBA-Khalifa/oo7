<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">packages/oo7-parity/src/index.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#oo7-parity-src">oo7-parity/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7-parity/src/index.js~Bonds.html">Bonds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBonds">createBonds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNotOwned">isNotOwned</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isOwned">isOwned</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-bonds">bonds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-options">options</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#oo7-parity-src-abis">oo7-parity/src/abis</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-abiPolyfill">abiPolyfill</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BadgeABI">BadgeABI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BadgeRegABI">BadgeRegABI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-GitHubHintABI">GitHubHintABI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OperationsABI">OperationsABI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RegistryExtras">RegistryExtras</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TokenABI">TokenABI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TokenRegABI">TokenRegABI</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#oo7-parity-src-utils">oo7-parity/src/utils</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-capitalizeFirstLetter">capitalizeFirstLetter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cleanup">cleanup</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-combineValue">combineValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-defDenom">defDenom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-denominationMultiplier">denominationMultiplier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatBalance">formatBalance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatBlockNumber">formatBlockNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatToExponential">formatToExponential</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatValue">formatValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatValueNoDenom">formatValueNoDenom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-interpretQuantity">interpretQuantity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-interpretRender">interpretRender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isAddressValid">isAddressValid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNullData">isNullData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-removeSigningPrefix">removeSigningPrefix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sha3">sha3</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-singleton">singleton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-splitSignature">splitSignature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-splitValue">splitValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toChecksumAddress">toChecksumAddress</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-asciiToHex">asciiToHex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-bytesToHex">bytesToHex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-denominations">denominations</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-hexToAscii">hexToAscii</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#oo7-lib">oo7/lib</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/bond.js~Bond.html">Bond</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/bondCache.js~BondCache.html">BondCache</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/bondProxy.js~BondProxy.html">BondProxy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/notReadyBond.js~NotReadyBond.html">NotReadyBond</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/reactiveBond.js~ReactiveBond.html">ReactiveBond</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/reactivePromise.js~ReactivePromise.html">ReactivePromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/readyBond.js~ReadyBond.html">ReadyBond</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/timeBond.js~TimeBond.html">TimeBond</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/oo7/lib/transformBond.js~TransformBond.html">TransformBond</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">packages/oo7-parity/src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// (C) Copyright 2016-2017 Parity Technologies (UK) Ltd.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* eslint-disable no-return-assign */
/* eslint-disable no-proto */

// TODO [Document auxilary types]

const oo7 = require(&apos;oo7&apos;);
const ParityApi = require(&apos;@parity/api&apos;);

const {
	asciiToHex,
	bytesToHex,
	hexToAscii,
	isAddressValid,
	toChecksumAddress,
	sha3,
	capitalizeFirstLetter,
	singleton,
	denominations,
	denominationMultiplier,
	interpretRender,
	combineValue,
	defDenom,
	formatValue,
	formatValueNoDenom,
	formatToExponential,
	interpretQuantity,
	splitValue,
	formatBalance,
	formatBlockNumber,
	isNullData,
	splitSignature,
	removeSigningPrefix,
	cleanup
} = require(&apos;./utils&apos;);

const {
	abiPolyfill,
	RegistryABI,
	RegistryExtras,
	GitHubHintABI,
	OperationsABI,
	BadgeRegABI,
	TokenRegABI,
	BadgeABI,
	TokenABI
} = require(&apos;./abis&apos;);

function defaultProvider () {
	if (typeof window !== &apos;undefined&apos; &amp;&amp; window.ethereum) {
		return window.ethereum;
	}

	try {
		if (typeof window !== &apos;undefined&apos; &amp;&amp; window.parent &amp;&amp; window.parent.ethereum) {
			return window.parent.ethereum;
		}
	} catch (e) {}

	return new ParityApi.Provider.Http(&apos;http://localhost:8545&apos;);
}

class Bonds {
	/**
	 * Creates a new oo7-parity bonds aggregate object with given ethereum provider.
	 *
	 * Additional documentation can be found at https://wiki.parity.io/oo7-Parity-Reference.html
	 *
	 * @param {?Provider} provider Web3-compatible transport Provider (i.e. `window.ethereum`). Uses a sane default if not provided.
	 * @returns {Bonds}
	 */
	constructor (provider = defaultProvider()) {
		if (!this) {
			return createBonds({ api: new ParityApi(provider) });
		}

		/**
		 *
		 * A {@link Bond} representing latest time. Updated every second.
		 *
		 * @type {TimeBond}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.time
		 *	.tie(console.log) // prints time periodically
		 */
		this.time = null;

		/**
		 * A {@link Bond} representing latest block number.
		 * Alias for {@link Bonds.blockNumber}
		 *
		 * @type {Bond.&lt;Number&gt;}
		 */
		this.height = null;

		/**
		 * A {@link Bond} representing latest block number.
		 *
		 * @type {Bond.&lt;Number&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.blockNumber
		 *	.tie(console.log) // prints latest block number when it changes
		 */
		this.blockNumber = null;

		/**
		 * A function returning bond that represents given block content.
		 *
		 * @param {string|number|Bond} number block number
		 * @returns {Bond.&lt;Block&gt;} block bond
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.blockByNumber(bonds.height)
		 *	.tie(console.log) // prints latest block
		 */
		this.blockByNumber = null;

		/**
		 * A function returning bond that represents given block content.
		 *
		 * @param {string|number|Bond} hash block hash
		 * @returns {Bond.&lt;Block&gt;} block bond
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.blockByHash(&apos;0x2b23d04567313fa141ca396f1e2620b62ab0c5d69f8c77157118f8d7671e1f4d&apos;)
		 *	.tie(console.log) // prints block with given hash
		 */
		this.blockByHash = null;

		/**
		 * Similar to {@link Bonds.blockByNumber} and {@link Bonds.blockByHash},
		 * but accepts both hashes and numbers as arguments.
		 *
		 * @param {string|number|Bond} hashOrNumber block hash or block number
		 * @returns {Bond.&lt;Block&gt;} block bond
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.findBlock(&apos;0x2b23d04567313fa141ca396f1e2620b62ab0c5d69f8c77157118f8d7671e1f4d&apos;)
		 *	.tie(console.log) // prints block with given hash
		 */
		this.findBlock = null;

		/**
		 * A subscriptable version of {@link Bonds.findBlock}
		 *
		 * You can retrieve bonds given block numbers or hashes or other Bonds.
		 *
		 * @type {Object.&lt;string|number|Bond, Bond&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.blocks[&apos;0x2b23d04567313fa141ca396f1e2620b62ab0c5d69f8c77157118f8d7671e1f4d&apos;]
		 *	.tie(console.log) // prints block with given hash
		 *
		 * bonds
		 *	.blocks[bonds.height]
		 *	.tie(console.log) // prints latest block every time it changes
		 */
		this.blocks = null;

		/**
		 * A {@link Bond} for latest block.
		 *
		 * @type {Bond.&lt;Block&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.head
		 *	.tie(console.log) // prints latest block every time it changes
		 *
		 */
		this.head = null;

		/**
		 * A {@link Bond} for currently set block author.
		 * Represents a result of `eth_coinbase` RPC call.
		 *
		 * @type {Bond.&lt;Address&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.author
		 *	.tie(console.log) // prints currently set block author (coinbase/miner) every time it changes
		 *
		 */
		this.author = null;

		/**
		 * List of accounts managed by the node.
		 *
		 * @type {Bond.&lt;Address[]&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.accounts
		 *	.tie(console.log) // prints accounts list every time it changes
		 *
		 */
		this.accounts = null;

		/**
		 * User-selected default account for this dapp.
		 *
		 * @type {Bond.&lt;Address&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.defaultAccount
		 *	.tie(console.log) // prints default account every time it changes
		 *
		 */
		this.defaultAccount = null;

		/**
		 * Alias for {@link Bonds.defaultAccount}
		 *
		 * @type {Bond.&lt;Address&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.me
		 *	.tie(console.log) // prints default account every time it changes
		 *
		 */
		this.me = null;
		/**
		 * Posts a transaction to the network.
		 *
		 * @param {TransactionRequest} tx Transaction details
		 * @returns {ReactivePromise.&lt;TransactionStatus&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.post({ to: bonds.me, value: 0  })
		 *	.tie(console.log) // Reports transaction progress
		 */
		this.post = null;
		/**
		 * Returns a signature of given message
		 *
		 * @param {Hash|Bond} hash Hash to sign
		 * @param {?Address|Bond} from Optional account that should be used for signing.
		 * @returns {ReactivePromise.&lt;SignStatus&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.sign(&apos;0x2ea2e504d09c458dbadc703112125564d53ca03c27a5b28e7b3e2b5804289c45&apos;)
		 *	.tie(console.log) // Reports signing progress
		 */
		this.sign = null;

		/**
		 * Returns balance of given address.
		 *
		 * @param {string|Bond.&lt;Address&gt;} address
		 * @returns {Bond.&lt;BigNumber&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.balance(bonds.me)
		 *	.tie(console.log) // prints default account balance every time any of them changes
		 *
		 */
		this.balance = null;

		/**
		 * Returns code of given address.
		 *
		 * @param {string|Bond.&lt;Address&gt;} address
		 * @returns {Bond.&lt;Bytes&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.code(bonds.me)
		 *	.tie(console.log) // prints default account code every time any of them changes
		 *
		 */
		this.code = null;

		/**
		 * Returns the nonce of given address.
		 *
		 * @param {string|Bond.&lt;Address&gt;} address
		 * @returns {Bond.&lt;BigNumber&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.nonce(bonds.me)
		 *	.tie(console.log) // prints default account nonce every time any of them changes
		 *
		 */
		this.nonce = null;

		/**
		 * Returns storage at given index of an address.
		 *
		 * @param {string|Bond.&lt;Address&gt;} address Contract address
		 * @param {string|number|Bond.&lt;H256&gt;} storageIdx Contract storage index
		 * @returns {Bond.&lt;BigNumber&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.storageAt(bonds.me, 0)
		 *	.tie(console.log) // prints default account storage at position 0 every time any of them changes
		 *
		 */
		this.storageAt = null;

		/**
		 * Returns node&apos;s syncing status.
		 * If the node is fully synced this will return `false`.
		 *
		 * @type {Bond.&lt;bool&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.syncing
		 *	.tie(console.log) // prints sync status every time it changes
		 *
		 */
		this.syncing = null;
		/**
		 * Returns node&apos;s authoring status.
		 * If the node is not authoring blocks this will return `false`.
		 *
		 * @type {Bond.&lt;bool&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.authoring
		 *	.tie(console.log) // prints authoring status every time it changes
		 *
		 */
		this.authoring = null;
		/**
		 * Reported hashrate.
		 * If there is an external miner connected to the node it will return reported values.
		 *
		 * @type {Bond.&lt;BigNumber&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.hashrate
		 *	.tie(console.log) // prints current average hashrate
		 *
		 */
		this.hashrate = null;
		this.ethProtocolVersion = null;
		/**
		 * Suggested gas price value. (Gas Price Oracle)
		 * This returns a suggested gas price for next transaction. The estimation is based on statistics from last blocks.
		 *
		 * @type {Bond.&lt;BigNumber&gt;}
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.gasPrice
		 *	.tie(console.log) // prints current gas price suggestion
		 *
		 */
		this.gasPrice = null;
		/**
		 * Estimates gas required to execute given transaction
		 *
		 * @param {{ from: ?Address, to: ?Address, data: ?Bytes }} call Transaction request
		 * @returns {Bond.&lt;BigNumber&gt;} gas estimate
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.estimateGas({ from: bonds.me, to: &apos;0x00D6Cc1BA9cf89BD2e58009741f4F7325BAdc0ED&apos; })
		 *	.tie(console.log) // prints current gas estimate
		 *
		 */
		this.estimateGas = null;

		/**
		 * Returns block transaction count given block number or hash.
		 *
		 * @param {string|number|Bond} block block number or hash
		 * @returns {Bond.&lt;Number&gt;} number of transactions in block
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.blockTransactionCount(bonds.blockNumber)
		 *	.tie(console.log) // prints number of transactions in latest block
		 *
		 */
		this.blockTransactionCount = null;
		/**
		 * Returns uncle count given block number or hash.
		 *
		 * @param {string|number|Bond} block block number or hash
		 * @returns {Bond.&lt;Number&gt;} number of uncles in a block
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.uncleCount(bonds.blockNumber)
		 *	.tie(console.log) // prints number of uncles in latest block
		 *
		 */
		this.uncleCount = null;
		/**
		 * Returns uncle given block number or hash and uncle index
		 *
		 * @param {string|number|Bond} block block number or hash
		 * @param {string|number|Bond} index index of an uncle within a block
		 * @returns {Bond.&lt;Header&gt;} uncle header at that index
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.uncle(bonds.blockNumber, 0)
		 *	.tie(console.log) // prints the first uncle in latest block
		 *
		 */
		this.uncle = null;
		/**
		 * Returns transaction given block number or hash and transaction index
		 *
		 * @param {string|number|Bond} block block number or hash
		 * @param {string|number|Bond} index index of a transaction within a block
		 * @returns {Bond.&lt;Transaction&gt;} transaction at that index
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.transaction(bonds.blockNumber, 0)
		 *	.tie(console.log) // prints the first uncle in latest block
		 *
		 */
		this.transaction = null;
		/**
		 * Returns receipt given transaction hash.
		 *
		 * @param {string|number|Bond} hash transaction hash
		 * @returns {Bond.&lt;TransactionReceipt&gt;} transaction at that index
		 *
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.receipt(bonds.transaction(bonds.height, 0).map(x =&gt; x ? x.hash : undefined))
		 *	.tie(console.log) // prints receipt of first transaction in latest block
		 *
		 */
		this.receipt = null;

		/**
		 * Returns client version string. (`web3_clientVersion`).
		 *
		 * @type {Bond.&lt;String&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.clientVersion
		 *	.tie(console.log)
		 *
		 */
		this.clientVersion = null;

		/**
		 * Returns current peer count. (`net_peerCount`).
		 *
		 * @type {Bond.&lt;Number&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.peerCount
		 *	.tie(console.log)
		 *
		 */
		this.peerCount = null;
		/**
		 * Returns true if the node is actively listening for network connections.
		 *
		 * @type {Bond.&lt;bool&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.listening
		 *	.tie(console.log)
		 *
		 */
		this.listening = null;
		/**
		 * Returns chain id (used for chain replay protection).
		 * NOTE: It&apos;s _not_ network id.
		 *
		 * @type {Bond.&lt;Number&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.chainId
		 *	.tie(console.log)
		 *
		 */
		this.chainId = null;

		/**
		 * Returns a hash of content under given URL.
		 *
		 * @param {string|Bond} url URL of the content
		 * @returns {Bond.&lt;string&gt;} hash of the content
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.hashContent(&apos;https://google.com&apos;)
		 *	.tie(console.log)
		 *
		 */
		this.hashContent = null;
		this.gasPriceHistogram = null;
		this.accountsInfo = null;
		this.allAccontsInfo = null;
		this.hardwareAccountsInfo = null;
		this.mode = null;

		this.defaultExtraData = null;
		this.extraData = null;
		this.gasCeilTarget = null;
		this.gasFloorTarget = null;
		this.minGasPrice = null;
		this.transactionsLimit = null;
		/**
		 * Returns a string name of currently connected chain.
		 *
		 * @type {Bond.&lt;string&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.chainName
		 *	.tie(console.log)
		 */
		this.chainName = null;
		/**
		 * Returns a status of currently connected chain.
		 *
		 * @type {Bond.&lt;object&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.chainStatus
		 *	.tie(console.log)
		 */
		this.chainStatus = null;

		this.peers = null;
		this.enode = null;
		this.nodePort = null;
		this.nodeName = null;
		this.signerPort = null;
		this.dappsPort = null;
		this.dappsInterface = null;

		this.nextNonce = null;
		this.pending = null;
		this.local = null;
		this.future = null;
		this.pendingStats = null;
		this.unsignedCount = null;

		this.releaseInfo = null;
		this.versionInfo = null;
		this.consensusCapability = null;
		this.upgradeReady = null;

		/**
		 * Replays (re-executes) a transaction. Returns requested traces of execution.
		 *
		 * @param {string} hash Transaction hash
		 * @param {String[]} traces Any subset of `trace`,`vmTrace`,`stateDiff`.
		 * @returns {Bond.&lt;object&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.replayTx(&apos;0x2ea2e504d09c458dbadc703112125564d53ca03c27a5b28e7b3e2b5804289c45&apos;, [&apos;trace&apos;])
		 *	.tie(console.log)
		 */
		this.replayTx = null;
		/**
		 * Executs a transaction and collects traces.
		 *
		 * @param {TransactionRequest} transaction Transaction request
		 * @param {String[]} traces Any subset of `trace`,`vmTrace`,`stateDiff`.
		 * @param {string|number|Bond} block Block number or hash
		 * @returns {Bond.&lt;object&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.callTx({
		 *		from: bonds.me,
		 *		to: bonds.registry.address
		 *	}, [&apos;trace&apos;], &apos;latest&apos;)
		 *	.tie(console.log)
		 */
		this.callTx = null;

		/**
		 * Deploys a new contract
		 *
		 * @param {string|Bytes} init Initialization bytecode
		 * @param {ABI} abi Contract ABI
		 * @param {{from: ?Address, gas: ?BigNumber, gasPrice: ?BigNumber, nonce: ?BigNumber}} options Deployment options
		 * @returns {ReactivePromise.&lt;DeployStatus&gt;}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.deployContract(&apos;0x1234&apos;, abi, {})
		 *	.tie(console.log) // Reports deployment progress
		 */
		this.deployContract = null;
		/**
		 * Creates bond-enabled contract object for existing contract.
		 *
		 * @param {string|Bond} address Contract address
		 * @param {ABI} abi Contract ABI
		 * @param {?ABI} extras Additional methods not defined in the ABI.
		 * @returns {Contract}
		 * @example
		 * const { bonds } = require(&apos;oo7-parity&apos;)
		 *
		 * bonds
		 *	.makeContract(bonds.me, abi)
		 *	.someMethod()
		 *	.tie(console.log) // returns a result of someMethod call
		 */
		this.makeContract = null;

		/**
		 * Parity registry contract instance.
		 * @type {Contract.&lt;Registry&gt;}
		 */
		this.registry = null;

		/**
		 * Parity registry contract instance.
		 * @type {Contract.&lt;GithubHint&gt;}
		 */
		this.githubhint = null;
		/**
		 * Parity registry contract instance.
		 * @type {Contract.&lt;Operations&gt;}
		 */
		this.operations = null;
		/**
		 * Parity registry contract instance.
		 * @type {Contract.&lt;BadgeReg&gt;}
		 */
		this.badgereg = null;
		/**
		 * Parity registry contract instance.
		 * @type {Contract.&lt;TokenReg&gt;}
		 */
		this.tokenreg = null;

		/**
		 * A {@link Bond} representing all currently registered badges from BadgeReg.
		 *
		 * @type {Bond.&lt;{id:string,name:string,img:string,caption:string,badge:Contract}[]&gt;}
		 */
		this.badges = null;
		/**
		 * Returns a list of badges for given address.
		 *
		 * @param {Address} address
		 * @returns {Bond.&lt;Badge[]&gt;} see {@link Bonds.badges}
		 */
		this.badgesOf = null;

		/**
		 * A {@link Bond} representing all currently registered tokens from TokenReg.
		 *
		 * @type {Bond.&lt;{id:string,tla:string,base:string,name:string,owner:address,img:string,caption:string}[]&gt;}
		 */
		this.tokens = null;
		/**
		 * Returns a list of tokens with a non-empty balance for given address.
		 *
		 * @param {Address} address
		 * @returns {Bond.&lt;Token[]&gt;} see {@link Bonds.tokens}
		 */
		this.tokensOf = null;

		return this;
	}
}

function isNumber (n) {
	return typeof (n) === &apos;number&apos; || (typeof (n) === &apos;string&apos; &amp;&amp; n.match(/^[0-9]+$/));
}

function memoized (f) {
	var memo;
	return function () {
		if (memo === undefined) { memo = f(); }
		return memo;
	};
}

function overlay (base, top) {
	Object.keys(top).forEach(k =&gt; {
		base[k] = top[k];
	});
	return base;
}

function transactionPromise (api, tx, progress, f) {
	progress({initialising: null});
	let condition = tx.condition || null;
	Promise.all([api().eth.accounts(), api().eth.gasPrice()])
		.then(([a, p]) =&gt; {
			progress({estimating: null});
			tx.from = tx.from || a[0];
			tx.gasPrice = tx.gasPrice || p;
			return tx.gas || api().eth.estimateGas(tx);
		})
		.then(g =&gt; {
			progress({estimated: g});
			tx.gas = tx.gas || g;
			return api().parity.postTransaction(tx);
		})
		.then(signerRequestId =&gt; {
			progress({requested: signerRequestId});
			return api().pollMethod(&apos;parity_checkRequest&apos;, signerRequestId);
		})
		.then(transactionHash =&gt; {
			if (condition) {
				progress(f({signed: transactionHash, scheduled: condition}));
				return {signed: transactionHash, scheduled: condition};
			} else {
				progress({signed: transactionHash});
				return api()
					.pollMethod(&apos;eth_getTransactionReceipt&apos;, transactionHash, (receipt) =&gt; receipt &amp;&amp; receipt.blockNumber &amp;&amp; !receipt.blockNumber.eq(0))
					.then(receipt =&gt; {
						progress(f({confirmed: receipt}));
						return receipt;
					});
			}
		})
		.catch(error =&gt; {
			progress({failed: error});
		});
}

class DeployContract extends oo7.ReactivePromise {
	constructor (initBond, abiBond, optionsBond, api) {
		super([initBond, abiBond, optionsBond, bonds.registry], [], ([init, abi, options, registry]) =&gt; {
			options.data = init;
			delete options.to;
			let progress = this.trigger.bind(this);
			transactionPromise(api, options, progress, status =&gt; {
				if (status.confirmed) {
					status.deployed = bonds.makeContract(status.confirmed.contractAddress, abi, options.extras || []);
				}
				return status;
			});
			// TODO: consider allowing registry of the contract here.
		}, false);
		this.then(_ =&gt; null);
	}
	isDone (s) {
		return !!(s.failed || s.confirmed);
	}
}

class Transaction extends oo7.ReactivePromise {
	constructor (tx, api) {
		super([tx], [], ([tx]) =&gt; {
			let progress = this.trigger.bind(this);
			transactionPromise(api, tx, progress, _ =&gt; _);
		}, false);
		this.then(_ =&gt; null);
	}
	isDone (s) {
		return !!(s.failed || s.confirmed);
	}
}

/**
 * @param {{api: ParityApi}} Options object
 * @returns {Bonds}
 */
function createBonds (options) {
	const bonds = new Bonds();

	// We only ever use api() at call-time of this function; this allows the
	// options (particularly the transport option) to be changed dynamically
	// and the datastructure to be reused.
	const api = () =&gt; options.api;
	const util = ParityApi.util;

	class TransformBond extends oo7.TransformBond {
		constructor (f, a = [], d = [], outResolveDepth = 0, resolveDepth = 1, latched = true, mayBeNull = true) {
			super(f, a, d, outResolveDepth, resolveDepth, latched, mayBeNull, api());
		}
		map (f, outResolveDepth = 0, resolveDepth = 1) {
			return new TransformBond(f, [this], [], outResolveDepth, resolveDepth);
		}
		sub (name, outResolveDepth = 0, resolveDepth = 1) {
			return new TransformBond((r, n) =&gt; r[n], [this, name], [], outResolveDepth, resolveDepth);
		}
		static all (list) {
			return new TransformBond((...args) =&gt; args, list);
		}
	}

	class SubscriptionBond extends oo7.Bond {
		constructor (module, rpcName, options = []) {
			super();
			this.module = module;
			this.rpcName = rpcName;
			this.options = [(_, n) =&gt; this.trigger(n), ...options];
		}
		initialise () {
			// promise instead of id because if a dependency triggers finalise() before id&apos;s promise is resolved the unsubscribing would call with undefined
			this.subscription = api().pubsub[this.module][this.rpcName](...this.options);
		}
		finalise () {
			this.subscription.then(id =&gt; api().pubsub.unsubscribe([id]));
		}
		map (f, outResolveDepth = 0, resolveDepth = 1) {
			return new TransformBond(f, [this], [], outResolveDepth, resolveDepth);
		}
		sub (name, outResolveDepth = 0, resolveDepth = 1) {
			return new TransformBond((r, n) =&gt; r[n], [this, name], [], outResolveDepth, resolveDepth);
		}
		static all (list) {
			return new TransformBond((...args) =&gt; args, list);
		}
	}

	class Signature extends oo7.ReactivePromise {
		constructor (message, from) {
			super([message, from], [], ([message, from]) =&gt; {
				api().parity.postSign(from, asciiToHex(message))
					.then(signerRequestId =&gt; {
						this.trigger({requested: signerRequestId});
						return api().pollMethod(&apos;parity_checkRequest&apos;, signerRequestId);
					})
					.then(signature =&gt; {
						this.trigger({
							signed: splitSignature(signature)
						});
					})
					.catch(error =&gt; {
						console.error(error);
						this.trigger({failed: error});
					});
			}, false);
			this.then(_ =&gt; null);
		}
		isDone (s) {
			return !!s.failed || !!s.signed;
		}
	}

	function call (addr, method, args, options) {
		let data = util.abiEncode(method.name, method.inputs.map(f =&gt; f.type), args);
		let decode = d =&gt; util.abiDecode(method.outputs.map(f =&gt; f.type), d);
		return api().eth.call(overlay({to: addr, data: data}, options)).then(decode);
	}

	function post (addr, method, args, options) {
		let toOptions = (addr, method, options, ...args) =&gt; {
			return overlay({to: addr, data: util.abiEncode(method.name, method.inputs.map(f =&gt; f.type), args)}, options);
		};
		// inResolveDepth is 2 to allow for Bonded `condition`values which are
		// object values in `options`.
		return new Transaction(new TransformBond(toOptions, [addr, method, options, ...args], [], 0, 2), api);
	}

	function presub (f) {
		return new Proxy(f, {
			get (receiver, name) {
				if (typeof (name) === &apos;string&apos; || typeof (name) === &apos;number&apos;) {
					return typeof (receiver[name]) !== &apos;undefined&apos; ? receiver[name] : receiver(name);
				} else if (typeof (name) === &apos;symbol&apos; &amp;&amp; oo7.Bond.knowSymbol(name)) {
					return receiver(oo7.Bond.fromSymbol(name));
				} else {
					throw new Error(`Weird value type to be subscripted by: ${typeof (name)}: ${JSON.stringify(name)}`);
				}
			}
		});
	}

	let useSubs = false;

	bonds.time = new oo7.TimeBond();

	if (!useSubs) {
		bonds.height = new TransformBond(() =&gt; api().eth.blockNumber().then(_ =&gt; +_), [], [bonds.time]);

		let onAccountsChanged = bonds.time; // TODO: more accurate notification
		let onHardwareAccountsChanged = bonds.time; // TODO: more accurate notification
		let onHeadChanged = bonds.height;	// TODO: more accurate notification
		//	let onReorg = undefined;	// TODO make more accurate.
		let onSyncingChanged = bonds.time;
		let onAuthoringDetailsChanged = bonds.time;
		let onPeerNetChanged = bonds.time; // TODO: more accurate notification
		let onPendingChanged = bonds.time; // TODO: more accurate notification
		let onUnsignedChanged = bonds.time; // TODO: more accurate notification
		let onAutoUpdateChanged = bonds.height;

		// eth_
		bonds.blockNumber = bonds.height;
		bonds.blockByNumber = x =&gt; new TransformBond(x =&gt; api().eth.getBlockByNumber(x), [x], []).subscriptable();// TODO: chain reorg that includes number x
		bonds.blockByHash = x =&gt; new TransformBond(x =&gt; api().eth.getBlockByHash(x), [x]).subscriptable();
		bonds.findBlock = hashOrNumberBond =&gt; new TransformBond(hashOrNumber =&gt; isNumber(hashOrNumber)
			? api().eth.getBlockByNumber(hashOrNumber)
			: api().eth.getBlockByHash(hashOrNumber),
		[hashOrNumberBond], [/* onReorg */]).subscriptable();// TODO: chain reorg that includes number x, if x is a number
		bonds.blocks = presub(bonds.findBlock);
		bonds.block = bonds.blockByNumber(bonds.height);	// TODO: DEPRECATE AND REMOVE
		bonds.head = new TransformBond(() =&gt; api().eth.getBlockByNumber(&apos;latest&apos;), [], [onHeadChanged]).subscriptable();// TODO: chain reorgs
		bonds.author = new TransformBond(() =&gt; api().eth.coinbase(), [], [onAccountsChanged]);
		bonds.accounts = new TransformBond(a =&gt; a.map(util.toChecksumAddress), [new TransformBond(() =&gt; api().eth.accounts(), [], [onAccountsChanged])]).subscriptable();
		bonds.defaultAccount = bonds.accounts[0];	// TODO: make this use its subscription
		bonds.me = bonds.accounts[0];
		// TODO [ToDr] document (Post &amp; Sign)
		bonds.post = tx =&gt; new Transaction(tx, api);
		bonds.sign = (message, from = bonds.me) =&gt; new Signature(message, from);

		bonds.balance = x =&gt; new TransformBond(x =&gt; api().eth.getBalance(x), [x], [onHeadChanged]);
		bonds.code = x =&gt; new TransformBond(x =&gt; api().eth.getCode(x), [x], [onHeadChanged]);
		bonds.nonce = x =&gt; new TransformBond(x =&gt; api().eth.getTransactionCount(x).then(_ =&gt; +_), [x], [onHeadChanged]);
		bonds.storageAt = (x, y) =&gt; new TransformBond((x, y) =&gt; api().eth.getStorageAt(x, y), [x, y], [onHeadChanged]);

		bonds.syncing = new TransformBond(() =&gt; api().eth.syncing(), [], [onSyncingChanged]);
		bonds.hashrate = new TransformBond(() =&gt; api().eth.hashrate(), [], [onAuthoringDetailsChanged]);
		bonds.authoring = new TransformBond(() =&gt; api().eth.mining(), [], [onAuthoringDetailsChanged]);
		bonds.ethProtocolVersion = new TransformBond(() =&gt; api().eth.protocolVersion(), [], []);
		bonds.gasPrice = new TransformBond(() =&gt; api().eth.gasPrice(), [], [onHeadChanged]);
		bonds.estimateGas = x =&gt; new TransformBond(x =&gt; api().eth.estimateGas(x), [x], [onHeadChanged, onPendingChanged]);

		bonds.blockTransactionCount = hashOrNumberBond =&gt; new TransformBond(
			hashOrNumber =&gt; isNumber(hashOrNumber)
				? api().eth.getBlockTransactionCountByNumber(hashOrNumber).then(_ =&gt; +_)
				: api().eth.getBlockTransactionCountByHash(hashOrNumber).then(_ =&gt; +_),
			[hashOrNumberBond], [/* onReorg */]);
		bonds.uncleCount = hashOrNumberBond =&gt; new TransformBond(
			hashOrNumber =&gt; isNumber(hashOrNumber)
				? api().eth.getUncleCountByBlockNumber(hashOrNumber).then(_ =&gt; +_)
				: api().eth.getUncleCountByBlockHash(hashOrNumber).then(_ =&gt; +_),
			[hashOrNumberBond], [/* onReorg */]).subscriptable();
		bonds.uncle = (hashOrNumberBond, indexBond) =&gt; new TransformBond(
			(hashOrNumber, index) =&gt; isNumber(hashOrNumber)
				? api().eth.getUncleByBlockNumber(hashOrNumber, index)
				: api().eth.getUncleByBlockHash(hashOrNumber, index),
			[hashOrNumberBond, indexBond], [/* onReorg */]).subscriptable();
		bonds.transaction = (hashOrNumberBond, indexOrNullBond) =&gt; new TransformBond(
			(hashOrNumber, indexOrNull) =&gt;
				indexOrNull === undefined || indexOrNull === null
					? api().eth.getTransactionByHash(hashOrNumber)
					: isNumber(hashOrNumber)
						? api().eth.getTransactionByBlockNumberAndIndex(hashOrNumber, indexOrNull)
						: api().eth.getTransactionByBlockHashAndIndex(hashOrNumber, indexOrNull),
			[hashOrNumberBond, indexOrNullBond], [/* onReorg */]).subscriptable();
		bonds.receipt = hashBond =&gt; new TransformBond(x =&gt; api().eth.getTransactionReceipt(x), [hashBond], []).subscriptable();

		// web3_
		bonds.clientVersion = new TransformBond(() =&gt; api().web3.clientVersion(), [], []);

		// net_
		bonds.peerCount = new TransformBond(() =&gt; api().net.peerCount().then(_ =&gt; +_), [], [onPeerNetChanged]);
		bonds.listening = new TransformBond(() =&gt; api().net.listening(), [], [onPeerNetChanged]);
		bonds.chainId = new TransformBond(() =&gt; api().net.version(), [], []);

		// parity_
		bonds.hashContent = u =&gt; new TransformBond(x =&gt; api().parity.hashContent(x), [u], [], false);
		bonds.gasPriceHistogram = new TransformBond(() =&gt; api().parity.gasPriceHistogram(), [], [onHeadChanged]).subscriptable();
		bonds.accountsInfo = new TransformBond(() =&gt; api().parity.accountsInfo(), [], [onAccountsChanged]).subscriptable(2);
		bonds.allAccountsInfo = new TransformBond(() =&gt; api().parity.allAccountsInfo(), [], [onAccountsChanged]).subscriptable(2);
		bonds.hardwareAccountsInfo = new TransformBond(() =&gt; api().parity.hardwareAccountsInfo(), [], [onHardwareAccountsChanged]).subscriptable(2);
		bonds.mode = new TransformBond(() =&gt; api().parity.mode(), [], [bonds.height]);

		// ...authoring
		bonds.defaultExtraData = new TransformBond(() =&gt; api().parity.defaultExtraData(), [], [onAuthoringDetailsChanged]);
		bonds.extraData = new TransformBond(() =&gt; api().parity.extraData(), [], [onAuthoringDetailsChanged]);
		bonds.gasCeilTarget = new TransformBond(() =&gt; api().parity.gasCeilTarget(), [], [onAuthoringDetailsChanged]);
		bonds.gasFloorTarget = new TransformBond(() =&gt; api().parity.gasFloorTarget(), [], [onAuthoringDetailsChanged]);
		bonds.minGasPrice = new TransformBond(() =&gt; api().parity.minGasPrice(), [], [onAuthoringDetailsChanged]);
		bonds.transactionsLimit = new TransformBond(() =&gt; api().parity.transactionsLimit(), [], [onAuthoringDetailsChanged]);

		// ...chain info
		bonds.chainName = new TransformBond(() =&gt; api().parity.netChain(), [], []);
		bonds.chainStatus = new TransformBond(() =&gt; api().parity.chainStatus(), [], [onSyncingChanged]).subscriptable();

		// ...networking
		bonds.peers = new TransformBond(() =&gt; api().parity.netPeers(), [], [onPeerNetChanged]).subscriptable(2);
		bonds.enode = new TransformBond(() =&gt; api().parity.enode(), [], []);
		bonds.nodePort = new TransformBond(() =&gt; api().parity.netPort().then(_ =&gt; +_), [], []);
		bonds.nodeName = new TransformBond(() =&gt; api().parity.nodeName(), [], []);
		bonds.signerPort = new TransformBond(() =&gt; api().parity.signerPort().then(_ =&gt; +_), [], []);
		bonds.dappsPort = new TransformBond(() =&gt; api().parity.dappsPort().then(_ =&gt; +_), [], []);
		bonds.dappsInterface = new TransformBond(() =&gt; api().parity.dappsInterface(), [], []);

		// ...transaction queue
		bonds.nextNonce = new TransformBond(() =&gt; api().parity.nextNonce().then(_ =&gt; +_), [], [onPendingChanged]);
		bonds.pending = new TransformBond(() =&gt; api().parity.pendingTransactions(), [], [onPendingChanged]);
		bonds.local = new TransformBond(() =&gt; api().parity.localTransactions(), [], [onPendingChanged]).subscriptable(3);
		bonds.future = new TransformBond(() =&gt; api().parity.futureTransactions(), [], [onPendingChanged]).subscriptable(2);
		bonds.pendingStats = new TransformBond(() =&gt; api().parity.pendingTransactionsStats(), [], [onPendingChanged]).subscriptable(2);
		bonds.unsignedCount = new TransformBond(() =&gt; api().parity.parity_unsignedTransactionsCount().then(_ =&gt; +_), [], [onUnsignedChanged]);

		// ...auto-update
		bonds.releasesInfo = new TransformBond(() =&gt; api().parity.releasesInfo(), [], [onAutoUpdateChanged]).subscriptable();
		bonds.versionInfo = new TransformBond(() =&gt; api().parity.versionInfo(), [], [onAutoUpdateChanged]).subscriptable();
		bonds.consensusCapability = new TransformBond(() =&gt; api().parity.consensusCapability(), [], [onAutoUpdateChanged]);
		bonds.upgradeReady = new TransformBond(() =&gt; api().parity.upgradeReady(), [], [onAutoUpdateChanged]).subscriptable();
	} else {
		bonds.height = new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;eth&apos;, &apos;blockNumber&apos;)]).subscriptable();

		let onAutoUpdateChanged = bonds.height;

		// eth_
		bonds.blockNumber = bonds.height;
		bonds.blockByNumber = numberBond =&gt; new TransformBond(number =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getBlockByNumber&apos;, [number]), [numberBond]).subscriptable();
		bonds.blockByHash = x =&gt; new TransformBond(x =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getBlockByHash&apos;, [x]), [x]).subscriptable();
		bonds.findBlock = hashOrNumberBond =&gt; new TransformBond(hashOrNumber =&gt; isNumber(hashOrNumber)
			? new SubscriptionBond(&apos;eth&apos;, &apos;getBlockByNumber&apos;, [hashOrNumber])
			: new SubscriptionBond(&apos;eth&apos;, &apos;getBlockByHash&apos;, [hashOrNumber]),
		[hashOrNumberBond]).subscriptable();
		bonds.blocks = presub(bonds.findBlock);
		bonds.block = bonds.blockByNumber(bonds.height);	// TODO: DEPRECATE AND REMOVE
		bonds.head = new SubscriptionBond(&apos;eth&apos;, &apos;getBlockByNumber&apos;, [&apos;latest&apos;]).subscriptable();
		bonds.author = new SubscriptionBond(&apos;eth&apos;, &apos;coinbase&apos;);
		bonds.me = new SubscriptionBond(&apos;parity&apos;, &apos;defaultAccount&apos;);
		bonds.defaultAccount = bonds.me;	// TODO: DEPRECATE
		bonds.accounts = new SubscriptionBond(&apos;eth&apos;, &apos;accounts&apos;).subscriptable();
		bonds.post = tx =&gt; new Transaction(tx, api);
		bonds.sign = (message, from = bonds.me) =&gt; new Signature(message, from);

		bonds.balance = x =&gt; new TransformBond(x =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getBalance&apos;, [x]), [x]);
		bonds.code = x =&gt; new TransformBond(x =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getCode&apos;, [x]), [x]);
		bonds.nonce = x =&gt; new TransformBond(x =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getTransactionCount&apos;, [x]), [x]); // TODO: then(_ =&gt; +_) Depth 2 if second TransformBond or apply to result
		bonds.storageAt = (x, y) =&gt; new TransformBond((x, y) =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getStorageAt&apos;, [x, y]), [x, y]);

		bonds.syncing = new SubscriptionBond(&apos;eth&apos;, &apos;syncing&apos;);
		bonds.hashrate = new SubscriptionBond(&apos;eth&apos;, &apos;hashrate&apos;);
		bonds.authoring = new SubscriptionBond(&apos;eth&apos;, &apos;mining&apos;);
		bonds.ethProtocolVersion = new SubscriptionBond(&apos;eth&apos;, &apos;protocolVersion&apos;);
		bonds.gasPrice = new SubscriptionBond(&apos;eth&apos;, &apos;gasPrice&apos;);
		bonds.estimateGas = x =&gt; new TransformBond(x =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;estimateGas&apos;, [x]), [x]);

		bonds.blockTransactionCount = hashOrNumberBond =&gt; new TransformBond(
			hashOrNumber =&gt; isNumber(hashOrNumber)
				? new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;eth&apos;, &apos;getBlockTransactionCountByNumber&apos;, [hashOrNumber])])
				: new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;eth&apos;, &apos;getBlockTransactionCountByHash&apos;, [hashOrNumber])]),
			[hashOrNumberBond]);
		bonds.uncleCount = hashOrNumberBond =&gt; new TransformBond(
			hashOrNumber =&gt; isNumber(hashOrNumber)
				? new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;eth&apos;, &apos;getUncleCountByBlockNumber&apos;, [hashOrNumber])])
				: new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;eth&apos;, &apos;getUncleCountByBlockHash&apos;, [hashOrNumber])]),
			[hashOrNumberBond]).subscriptable();
		bonds.uncle = (hashOrNumberBond, indexBond) =&gt; new TransformBond(
			(hashOrNumber, index) =&gt; isNumber(hashOrNumber)
				? new SubscriptionBond(&apos;eth&apos;, &apos;getUncleByBlockNumberAndIndex&apos;, [hashOrNumber, index])
				: new SubscriptionBond(&apos;eth&apos;, &apos;getUncleByBlockHashAndIndex&apos;, [hashOrNumber, index]),
			[hashOrNumberBond, indexBond]).subscriptable();

		bonds.transaction = (hashOrNumberBond, indexOrNullBond) =&gt; new TransformBond(
			(hashOrNumber, indexOrNull) =&gt;
				indexOrNull === undefined || indexOrNull === null
					? new SubscriptionBond(&apos;eth&apos;, &apos;getTransactionByHash&apos;, [hashOrNumber])
					: isNumber(hashOrNumber)
						? new SubscriptionBond(&apos;eth&apos;, &apos;getTransactionByBlockNumberAndIndex&apos;, [hashOrNumber, indexOrNull])
						: new SubscriptionBond(&apos;eth&apos;, &apos;getTransactionByBlockHashAndIndex&apos;, [hashOrNumber, indexOrNull]),
			[hashOrNumberBond, indexOrNullBond]).subscriptable();
		bonds.receipt = hashBond =&gt; new TransformBond(x =&gt; new SubscriptionBond(&apos;eth&apos;, &apos;getTransactionReceipt&apos;, [x]), [hashBond]).subscriptable();

		// web3_
		bonds.clientVersion = new TransformBond(() =&gt; api().web3.clientVersion(), [], []);

		// net_
		bonds.peerCount = new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;net&apos;, &apos;peerCount&apos;)]);
		bonds.listening = new SubscriptionBond(&apos;net&apos;, &apos;listening&apos;);
		bonds.chainId = new SubscriptionBond(&apos;net&apos;, &apos;version&apos;);

		// parity_
		bonds.hashContent = u =&gt; new TransformBond(x =&gt; api().parity.hashContent(x), [u], [], false);
		bonds.gasPriceHistogram = new SubscriptionBond(&apos;parity&apos;, &apos;gasPriceHistogram&apos;).subscriptable();
		bonds.mode = new SubscriptionBond(&apos;parity&apos;, &apos;mode&apos;);
		bonds.accountsInfo = new SubscriptionBond(&apos;parity&apos;, &apos;accountsInfo&apos;).subscriptable(2);
		bonds.allAccountsInfo = new SubscriptionBond(&apos;parity&apos;, &apos;allAccountsInfo&apos;).subscriptable(2);
		bonds.hardwareAccountsInfo = new SubscriptionBond(&apos;parity&apos;, &apos;hardwareAccountsInfo&apos;).subscriptable(2);

		// ...authoring
		bonds.defaultExtraData = new SubscriptionBond(&apos;parity&apos;, &apos;defaultExtraData&apos;);
		bonds.extraData = new SubscriptionBond(&apos;parity&apos;, &apos;extraData&apos;);
		bonds.gasCeilTarget = new SubscriptionBond(&apos;parity&apos;, &apos;gasCeilTarget&apos;);
		bonds.gasFloorTarget = new SubscriptionBond(&apos;parity&apos;, &apos;gasFloorTarget&apos;);
		bonds.minGasPrice = new SubscriptionBond(&apos;parity&apos;, &apos;minGasPrice&apos;);
		bonds.transactionsLimit = new SubscriptionBond(&apos;parity&apos;, &apos;transactionsLimit&apos;);

		// ...chain info
		bonds.chainName = new SubscriptionBond(&apos;parity&apos;, &apos;netChain&apos;);
		bonds.chainStatus = new SubscriptionBond(&apos;parity&apos;, &apos;chainStatus&apos;).subscriptable();

		// ...networking
		bonds.peers = new SubscriptionBond(&apos;parity&apos;, &apos;netPeers&apos;).subscriptable(2);
		bonds.enode = new SubscriptionBond(&apos;parity&apos;, &apos;enode&apos;);
		bonds.nodePort = new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;parity&apos;, &apos;netPort&apos;)]);
		bonds.nodeName = new SubscriptionBond(&apos;parity&apos;, &apos;nodeName&apos;);
		// Where defined ?
		bonds.signerPort = new TransformBond(() =&gt; api().parity.signerPort().then(_ =&gt; +_), [], []);
		bonds.dappsPort = new TransformBond(() =&gt; api().parity.dappsPort().then(_ =&gt; +_), [], []);
		bonds.dappsInterface = new TransformBond(() =&gt; api().parity.dappsInterface(), [], []);

		// ...transaction queue
		bonds.nextNonce = new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;parity&apos;, &apos;nextNonce&apos;)]);
		bonds.pending = new SubscriptionBond(&apos;parity&apos;, &apos;pendingTransactions&apos;).subscriptable();
		bonds.local = new SubscriptionBond(&apos;parity&apos;, &apos;localTransactions&apos;).subscriptable(3);
		bonds.future = new SubscriptionBond(&apos;parity&apos;, &apos;futureTransactions&apos;).subscriptable(2);
		bonds.pendingStats = new SubscriptionBond(&apos;parity&apos;, &apos;pendingTransactionsStats&apos;).subscriptable(2);
		bonds.unsignedCount = new TransformBond(_ =&gt; +_, [new SubscriptionBond(&apos;parity&apos;, &apos;unsignedTransactionsCount&apos;)]);
		bonds.requestsToConfirm = new SubscriptionBond(&apos;signer&apos;, &apos;requestsToConfirm&apos;);

		// ...auto-update
		bonds.releasesInfo = new SubscriptionBond(&apos;parity&apos;, &apos;releasesInfo&apos;).subscriptable();
		bonds.versionInfo = new SubscriptionBond(&apos;parity&apos;, &apos;versionInfo&apos;).subscriptable();
		bonds.consensusCapability = new SubscriptionBond(&apos;parity&apos;, &apos;consensusCapability&apos;).subscriptable();
		bonds.upgradeReady = new TransformBond(() =&gt; api().parity.upgradeReady(), [], [onAutoUpdateChanged]).subscriptable();
	}

	// trace TODO: Implement contract object with new trace_many feature
	bonds.replayTx = (x, whatTrace) =&gt; new TransformBond((x, whatTrace) =&gt; api().trace.replayTransaction(x, whatTrace), [x, whatTrace], []).subscriptable();
	bonds.callTx = (x, whatTrace, blockNumber) =&gt; new TransformBond((x, whatTrace, blockNumber) =&gt; api().trace.call(x, whatTrace, blockNumber), [x, whatTrace, blockNumber], []).subscriptable();

	function traceCall (addr, method, args, options) {
		let data = util.abiEncode(method.name, method.inputs.map(f =&gt; f.type), args);
		let decode = d =&gt; util.abiDecode(method.outputs.map(f =&gt; f.type), d);
		let traceMode = options.traceMode;
		delete options.traceMode;
		return api().trace.call(overlay({to: addr, data: data}, options), traceMode, &apos;latest&apos;).then(decode);
	}

	bonds.deployContract = function (init, abi, options = {}) {
		return new DeployContract(init, abi, options, api);
	};

	bonds.makeContract = function (address, abi, extras = [], debug = false) {
		var r = { address: address };
		let unwrapIfOne = a =&gt; a.length === 1 ? a[0] : a;
		abi.forEach(i =&gt; {
			if (i.type === &apos;function&apos; &amp;&amp; i.constant) {
				let f = function (...args) {
					var options = args.length === i.inputs.length + 1 ? args.pop() : {};
					if (args.length !== i.inputs.length) {
						throw new Error(`Invalid number of arguments to ${i.name}. Expected ${i.inputs.length}, got ${args.length}.`);
					}
					let f = (addr, ...fargs) =&gt; debug
						? traceCall(address, i, args, options)
						: call(addr, i, fargs, options)
							.then(rets =&gt; rets.map((r, o) =&gt; cleanup(r, i.outputs[o].type, api)))
							.then(unwrapIfOne);
					return new TransformBond(f, [address, ...args], [bonds.height]).subscriptable();	// TODO: should be subscription on contract events
				};
				r[i.name] = (i.inputs.length === 0) ? memoized(f) : (i.inputs.length === 1) ? presub(f) : f;
				r[i.name].args = i.inputs;
			}
		});
		extras.forEach(i =&gt; {
			let f = function (...args) {
				let expectedInputs = (i.numInputs || i.args.length);
				var options = args.length === expectedInputs + 1 ? args.pop() : {};
				if (args.length !== expectedInputs) {
					throw new Error(`Invalid number of arguments to ${i.name}. Expected ${expectedInputs}, got ${args.length}. ${args}`);
				}
				let c = abi.find(j =&gt; j.name === i.method);
				let f = (addr, ...fargs) =&gt; {
					let args = i.args.map((v, index) =&gt; v === null ? fargs[index] : typeof (v) === &apos;function&apos; ? v(fargs[index]) : v);
					return debug
						? traceCall(address, i, args, options)
						: call(addr, c, args, options).then(unwrapIfOne);
				};
				return new TransformBond(f, [address, ...args], [bonds.height]).subscriptable();	// TODO: should be subscription on contract events
			};
			r[i.name] = (i.args.length === 1) ? presub(f) : f;
			r[i.name].args = i.args;
		});
		abi.forEach(i =&gt; {
			if (i.type === &apos;function&apos; &amp;&amp; !i.constant) {
				r[i.name] = function (...args) {
					var options = args.length === i.inputs.length + 1 ? args.pop() : {};
					if (args.length !== i.inputs.length) { throw new Error(`Invalid number of arguments to ${i.name}. Expected ${i.inputs.length}, got ${args.length}. ${args}`); }
					return debug
						? traceCall(address, i, args, options)
						: post(address, i, args, options).subscriptable();
				};
				r[i.name].args = i.inputs;
			}
		});
		var eventLookup = {};
		abi.filter(i =&gt; i.type === &apos;event&apos;).forEach(i =&gt; {
			eventLookup[util.abiSignature(i.name, i.inputs.map(f =&gt; f.type))] = i.name;
		});

		function prepareIndexEncode (v, t, top = true) {
			if (v instanceof Array) {
				if (top) {
					return v.map(x =&gt; prepareIndexEncode(x, t, false));
				} else {
					throw new Error(&apos;Invalid type&apos;);
				}
			}
			var val;
			if (t === &apos;string&apos; || t === &apos;bytes&apos;) {
				val = util.sha3(v);
			} else {
				val = util.abiEncode(null, [t], [v]);
			}
			if (val.length !== 66) {
				throw new Error(&apos;Invalid length&apos;);
			}
			return val;
		}

		abi.forEach(i =&gt; {
			if (i.type === &apos;event&apos;) {
				r[i.name] = function (indexed = {}, params = {}) {
					return new TransformBond((addr, indexed) =&gt; {
						var topics = [util.abiSignature(i.name, i.inputs.map(f =&gt; f.type))];
						i.inputs.filter(f =&gt; f.indexed).forEach(f =&gt; {
							try {
								topics.push(indexed[f.name] ? prepareIndexEncode(indexed[f.name], f.type) : null);
							} catch (e) {
								throw new Error(`Couldn&apos;t encode indexed parameter ${f.name} of type ${f.type} with value ${indexed[f.name]}`);
							}
						});
						return api().eth.getLogs({
							address: addr,
							fromBlock: params.fromBlock || 0,
							toBlock: params.toBlock || &apos;pending&apos;,
							limit: params.limit || 10,
							topics: topics
						}).then(logs =&gt; logs.map(l =&gt; {
							l.blockNumber = +l.blockNumber;
							l.transactionIndex = +l.transactionIndex;
							l.logIndex = +l.logIndex;
							l.transactionLogIndex = +l.transactionLogIndex;
							var e = {};
							let unins = i.inputs.filter(f =&gt; !f.indexed);
							util.abiDecode(unins.map(f =&gt; f.type), l.data).forEach((v, j) =&gt; {
								let f = unins[j];
								if (v instanceof Array &amp;&amp; !f.type.endsWith(&apos;]&apos;)) {
									v = util.bytesToHex(v);
								}
								if (f.type.substr(0, 4) === &apos;uint&apos; &amp;&amp; +f.type.substr(4) &lt;= 48) {
									v = +v;
								}
								e[f.name] = v;
							});
							i.inputs.filter(f =&gt; f.indexed).forEach((f, j) =&gt; {
								if (f.type === &apos;string&apos; || f.type === &apos;bytes&apos;) {
									e[f.name] = l.topics[1 + j];
								} else {
									var v = util.abiDecode([f.type], l.topics[1 + j])[0];
									if (v instanceof Array) {
										v = util.bytesToHex(v);
									}
									if (f.type.substr(0, 4) === &apos;uint&apos; &amp;&amp; +f.type.substr(4) &lt;= 48) {
										v = +v;
									}
									e[f.name] = v;
								}
							});
							e.event = eventLookup[l.topics[0]];
							e.log = l;
							return e;
						}));
					}, [address, indexed], [bonds.height]).subscriptable();
				};
				r[i.name].args = i.inputs;
			}
		});
		return r;
	};

	if (useSubs) {
		bonds.registry = bonds.makeContract(new SubscriptionBond(&apos;parity&apos;, &apos;registryAddress&apos;), RegistryABI, RegistryExtras);
	} else {
		bonds.registry = bonds.makeContract(new TransformBond(() =&gt; api().parity.registryAddress(), [], [bonds.time]), RegistryABI, RegistryExtras);
	}

	bonds.githubhint = bonds.makeContract(bonds.registry.lookupAddress(&apos;githubhint&apos;, &apos;A&apos;), GitHubHintABI);
	bonds.operations = bonds.makeContract(bonds.registry.lookupAddress(&apos;operations&apos;, &apos;A&apos;), OperationsABI);
	bonds.badgereg = bonds.makeContract(bonds.registry.lookupAddress(&apos;badgereg&apos;, &apos;A&apos;), BadgeRegABI);
	bonds.tokenreg = bonds.makeContract(bonds.registry.lookupAddress(&apos;tokenreg&apos;, &apos;A&apos;), TokenRegABI);

	bonds.badges = new TransformBond(n =&gt; {
		var ret = [];
		for (var i = 0; i &lt; +n; ++i) {
			let id = i;
			ret.push(oo7.Bond.all([
				bonds.badgereg.badge(id),
				bonds.badgereg.meta(id, &apos;IMG&apos;),
				bonds.badgereg.meta(id, &apos;CAPTION&apos;)
			]).map(([[addr, name, owner], img, caption]) =&gt; ({
				id,
				name,
				img,
				caption,
				badge: bonds.makeContract(addr, BadgeABI)
			}))
			);
		}
		return ret;
	}, [bonds.badgereg.badgeCount()], [], 1);

	bonds.badgesOf = address =&gt; new TransformBond(
		(addr, bads) =&gt; bads.map(b =&gt; ({
			certified: b.badge.certified(addr),
			badge: b.badge,
			id: b.id,
			img: b.img,
			caption: b.caption,
			name: b.name
		})),
		[address, bonds.badges], [], 2
	).map(all =&gt; all.filter(_ =&gt; _.certified));

	bonds.tokens = new TransformBond(n =&gt; {
		var ret = [];
		for (var i = 0; i &lt; +n; ++i) {
			let id = i;
			ret.push(oo7.Bond.all([
				bonds.tokenreg.token(id),
				bonds.tokenreg.meta(id, &apos;IMG&apos;),
				bonds.tokenreg.meta(id, &apos;CAPTION&apos;)
			]).map(([[addr, tla, base, name, owner], img, caption]) =&gt; ({
				id,
				tla,
				base,
				name,
				img,
				caption,
				token: bonds.makeContract(addr, TokenABI)
			}))
			);
		}
		return ret;
	}, [bonds.tokenreg.tokenCount()], [], 1);

	bonds.tokensOf = address =&gt; new TransformBond(
		(addr, bads) =&gt; bads.map(b =&gt; ({
			balance: b.token.balanceOf(addr),
			token: b.token,
			id: b.id,
			name: b.name,
			tla: b.tla,
			base: b.base,
			img: b.img,
			caption: b.caption
		})),
		[address, bonds.tokens], [], 2
	).map(all =&gt; all.filter(_ =&gt; _.balance.gt(0)));

	bonds.namesOf = address =&gt; new TransformBond((reg, addr, accs) =&gt; ({
		owned: accs[addr] ? accs[addr].name : null,
		registry: reg || null
	}), [bonds.registry.reverse(address), address, bonds.accountsInfo]);

	bonds.registry.names = oo7.Bond.mapAll([bonds.registry.ReverseConfirmed({}, {limit: 100}), bonds.accountsInfo],
		(reg, info) =&gt; {
			let r = {};
			Object.keys(info).forEach(k =&gt; r[k] = info[k].name);
			reg.forEach(a =&gt; r[a.reverse] = bonds.registry.reverse(a.reverse));
			return r;
		}, 1);

	return bonds;
}

const t = defaultProvider();
const options = t ? { api: new ParityApi(t) } : null;
/** @type {Bonds} */
const bonds = options ? createBonds(options) : null;

const isOwned = addr =&gt; oo7.Bond.mapAll([addr, bonds.accounts], (a, as) =&gt; as.indexOf(a) !== -1);
const isNotOwned = addr =&gt; oo7.Bond.mapAll([addr, bonds.accounts], (a, as) =&gt; as.indexOf(a) === -1);

module.exports = {
	// Bonds stuff
	// abiPolyfill,
	options,
	bonds,
	Bonds,
	createBonds,

	// Util functions
	isOwned,
	isNotOwned,
	asciiToHex,
	bytesToHex,
	hexToAscii,
	isAddressValid,
	toChecksumAddress,
	sha3,
	capitalizeFirstLetter,
	singleton,
	denominations,
	denominationMultiplier,
	interpretRender,
	combineValue,
	defDenom,
	formatValue,
	formatValueNoDenom,
	formatToExponential,
	interpretQuantity,
	splitValue,
	formatBalance,
	formatBlockNumber,
	isNullData,
	splitSignature,
	removeSigningPrefix,
	cleanup,

	// ABIs
	abiPolyfill,
	RegistryABI,
	RegistryExtras,
	GitHubHintABI,
	OperationsABI,
	BadgeRegABI,
	TokenRegABI,
	BadgeABI,
	TokenABI
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
